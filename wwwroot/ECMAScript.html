<!DOCTYPE html>
<!-- saved from url=(0052)http://www.cplusplus.com/reference/regex/ECMAScript/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>ECMAScript syntax - C++ Reference</title>
<link rel="canonical" href="">
<link rel="stylesheet" type="text/css" href="./css/ECMAScript.css">
</head>
<body>
<div id="I_type">syntax specifications
</div>
<h1><span class="namespace" title="namespace std">std::</span>ECMAScript syntax<span class="C_ico cpp11warning" title="This page describes a feature introduced by the latest revision of the C++ standard (2011). Older compilers may not support it." alt="This page describes a feature introduced by the latest revision of the C++ standard (2011). Older compilers may not support it."></span></h1>
<p><i>Pulled from &lt;<a href="http://www.cplusplus.com/reference/regex/ECMAScript/">http://www.cplusplus.com/reference/regex/ECMAScript/</a>&gt; circa 2017. Copyright cplusplus.com</i></p>
<br />
<div id="I_description">ECMAScript regular expressions pattern syntax</div>
<section id="description">
The following syntax is used to construct regex objects (or assign) that have selected <tt>ECMAScript</tt> as its grammar.<br>
<br>
A <i>regular expression pattern</i> is formed by a sequence of characters.<br>
Regular expression operations look sequentially for matches between the characters of the pattern and the characters in the target sequence: In principle, each character in the pattern is matched against the corresponding character in the target sequence, one by one. But the regex syntax allows for special characters and expressions in the pattern:<br>
</section>
<br>
<section id="atoms">
<h3>Special pattern characters</h3>
Special pattern characters are characters (or sequences of characters) that have a special meaning when they appear in a regular expression pattern, either to represent a character that is difficult to express in a string, or to represent a category of characters. Each of these <i>special pattern characters</i> is matched in the target sequence against a single character (unless a quantifier specifies otherwise).<br>
<br>
<table class="boxed">
<tbody><tr><th>characters</th><th>description</th><th>matches</th></tr>
<tr><td><tt>.</tt></td><td>not newline</td><td>any character except <i>line terminators</i> (LF, CR, LS, PS).</td></tr>
<tr><td><tt><b>\t</b></tt></td><td>tab (HT)</td><td>a horizontal tab character (same as <tt><b>\u0009</b></tt>).</td></tr>
<tr><td><tt><b>\n</b></tt></td><td>newline (LF)</td><td>a newline (line feed) character (same as <tt><b>\u000A</b></tt>).</td></tr>
<tr><td><tt><b>\v</b></tt></td><td>vertical tab (VT)</td><td>a vertical tab character (same as <tt><b>\u000B</b></tt>).</td></tr>
<tr><td><tt><b>\f</b></tt></td><td>form feed (FF)</td><td>a form feed character (same as <tt><b>\u000C</b></tt>).</td></tr>
<tr><td><tt><b>\r</b></tt></td><td>carriage return (CR)</td><td>a carriage return character (same as <tt><b>\u000D</b></tt>).</td></tr>
<tr><td><tt><b>\c</b></tt><i>letter</i></td><td>control code</td><td>a control code character whose <i>code unit value</i> is the same as the remainder of dividing the <i>code unit value</i> of <i>letter</i> by 32.<br>
For example: <tt>\ca</tt> is the same as <tt>\u0001</tt>, <tt>\cb</tt> the same as <tt>\u0002</tt>, and so on...</td></tr>
<tr><td><tt><b>\x</b></tt><i>hh</i></td><td>ASCII character</td><td>a character whose <i>code unit value</i> has an hex value equivalent to the two hex digits <i>hh</i>.<br>
For example: <tt>\x4c</tt> is the same as <tt>L</tt>, or <tt>\x23</tt> the same as <tt>#</tt>.</td></tr>
<tr><td><tt><b>\u</b></tt><i>hhhh</i></td><td>unicode character</td><td>a character whose <i>code unit value</i> has an hex value equivalent to the four hex digits <i>hhhh</i>.</td></tr>
<tr><td><tt><b>\0</b></tt></td><td>null</td><td>a null character (same as <tt><b>\u0000</b></tt>).</td></tr>
<tr><td><tt><b>\</b></tt><i>int</i></td><td>backreference</td><td>the result of the submatch whose opening parenthesis is the <i>int</i>-th (<i>int</i> shall begin by a digit other than <tt>0</tt>). See <a href="#groups">groups</a> below for more info.</td></tr>
<tr><td><tt><b>\d</b></tt></td><td>digit</td><td>a decimal digit character (same as <tt><b>[<tt>[:digit:]</tt>]</b></tt>).</td></tr>
<tr><td><tt><b>\D</b></tt></td><td>not digit</td><td>any character that is not a decimal digit character (same as <tt><b>[^[:digit:]]</b></tt>).</td></tr>
<tr><td><tt><b>\s</b></tt></td><td>whitespace</td><td>a whitespace character (same as <tt><b>[<tt>[:space:]</tt>]</b></tt>).</td></tr>
<tr><td><tt><b>\S</b></tt></td><td>not whitespace</td><td>any character that is not a whitespace character (same as <tt><b>[^[:space:]]</b></tt>).</td></tr>
<tr><td><tt><b>\w</b></tt></td><td>word</td><td>an alphanumeric or underscore character (same as <tt><b>[_<tt>[:alnum:]</tt>]</b></tt>).</td></tr>
<tr><td><tt><b>\W</b></tt></td><td>not word</td><td>any character that is not an alphanumeric or underscore character (same as <tt><b>[^_[:alnum:]]</b></tt>).</td></tr>
<tr><td><tt><b>\</b></tt><i>character</i></td><td>character</td><td>the character <i>character</i> as it is, without interpreting its special meaning within a regex expression.<br>
Any <i>character</i> can be escaped except those which form any of the special character sequences above.<br>
Needed for: <tt>^ $ \ . * + ? ( ) [ ] { } |</tt></td></tr>
<tr><td><tt><b>[</b></tt><i>class</i><tt><b>]</b></tt></td><td>character class</td><td>the target character is part of the class (see <a href="#character_classes">character classes</a> below)</td></tr>
<tr><td><tt><b>[^</b></tt><i>class</i><tt><b>]</b></tt></td><td>negated character class</td><td>the target character is not part of the class (see <a href="#character_classes">character classes</a> below)</td></tr>
</tbody></table>
<br>
Notice that, in C++, character and string literals also escape characters using the backslash character (<tt>\</tt>), and this affects the syntax for constructing regular expressions from such types. For example:<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>std::regex e1 (<kbd>"\\d"</kbd>);  <cite>// regular expression: \d -&gt; matches a digit character</cite>
std::regex e2 (<kbd>"\\\\"</kbd>); <cite>// regular expression: \\ -&gt; matches a single backslash (\) character </cite></code></pre></td><td class="C_btnholder"></td></tr></tbody></table></div>
<br>
</section>
<br>
<section id="quantifiers">
<h3>Quantifiers</h3>
Quantifiers follow a character or a <i>special pattern character</i>. They can modify the amount of times that character is repeated in the match:<br>
<table class="boxed">
<tbody><tr><th>characters</th><th>times</th><th>effects</th></tr>
<tr><td><tt><b>*</b></tt></td><td>0 or more</td><td>The preceding atom is matched 0 or more times.</td></tr>
<tr><td><tt><b>+</b></tt></td><td>1 or more</td><td>The preceding atom is matched 1 or more times.</td></tr>
<tr><td><tt><b>?</b></tt></td><td>0 or 1</td><td>The preceding atom is optional (matched either 0 times or once).</td></tr>
<tr><td><tt><b>{</b></tt><i>int</i><tt><b>}</b></tt></td><td><i>int</i></td><td>The preceding atom is matched exactly <i>int</i> times.</td></tr>
<tr><td><tt><b>{</b></tt><i>int</i><tt><b>,}</b></tt></td><td><i>int</i> or more</td><td>The preceding atom is matched <i>int</i> or more times.</td></tr>
<tr><td><tt><b>{</b></tt><i>min</i><tt><b>,</b></tt><i>max</i><tt><b>}</b></tt></td><td>between <i>min</i> and <i>max</i></td><td>The preceding atom is matched at least <i>min</i> times, but not more than <i>max</i>.</td></tr>
</tbody></table>
By default, all these quantifiers are greedy (i.e., they take as many characters that meet the condition as possible). This behavior can be overridden to <i>ungreedy</i> (i.e., take as few characters that meet the condition as possible) by adding a <i>question mark</i> (<tt>?</tt>) after the quantifier.<br>
For example:<br>
Matching <tt>"(a+).*"</tt> against <tt>"aardvark"</tt> succeeds and yields <tt>aa</tt> as the first submatch.<br>
While matching <tt>"(a+?).*"</tt> against <tt>"aardvark"</tt> also succeeds, but yields <tt>a</tt> as the first submatch.<br>
</section>
<br>
<section id="groups">
<h3>Groups</h3>
Groups allow to apply quantifiers to a sequence of characters (instead of a single character). There are two kinds of groups:<br>
<table class="boxed">
<tbody><tr><th>characters</th><th>description</th><th>effects</th></tr>
<tr><td><tt><b>(</b></tt><i>subpattern</i><tt><b>)</b></tt></td><td>Group</td><td>Creates a backreference.<br>
</td></tr>
<tr><td><tt><b>(?:</b></tt><i>subpattern</i><tt><b>)</b></tt></td><td>Passive group</td><td>Does not create a backreference.</td></tr>
</tbody></table>
When a group creates a backreference, the characters that represent the <i>subpattern</i> in the target sequence are stored as a <i>submatch</i>. Each submatch is numbered after the order of appearance of their opening parenthesis (the first submatch is number 1, the second is number 2, and so on...).<br>
<br>
These <i>submatches</i> can be used in the regular expression itself to specify that the entire subpattern should appear again somewhere else (see <tt><b>\</b></tt><i>int</i> in the <a href="#atoms">special characters</a> list). They can also be used in the <i>replacement string</i> or retrieved in the match_results object filled by some regex operations.<br>
</section>
<br>
<section id="assertions">
<h3>Assertions</h3>
Assertions are conditions that do not consume characters in the target sequence: they do not describe a character, but a condition that must be fulfilled before or after a character.<br>
<table class="boxed">
<tbody><tr><th>characters</th><th>description</th><th>condition for match</th></tr>
<tr><td><tt><b>^</b></tt></td><td>Beginning of line</td><td>Either it is the beginning of the target sequence, or follows a <i>line terminator</i>.</td></tr>
<tr><td><tt><b>$</b></tt></td><td>End of line</td><td>Either it is the end of the target sequence, or precedes a <i>line terminator</i>.</td></tr>
<tr><td><tt><b>\b</b></tt></td><td>Word boundary</td><td>The previous character is a <i>word character</i> and the next is a <i>non-word character</i> (or vice-versa).<br>
Note: The beginning and the end of the target sequence are considered here as <i>non-word characters</i>.</td></tr>
<tr><td><tt><b>\B</b></tt></td><td>Not a word boundary</td><td>The previous and next characters are both <i>word characters</i> or both are <i>non-word characters</i>.<br>
Note: The beginning and the end of the target sequence are considered here as <i>non-word characters</i>.</td></tr>
<tr><td><tt><b>(?=</b></tt><i>subpattern</i><tt><b>)</b></tt></td><td>Positive lookahead</td><td>The characters following the assertion must match <i>subpattern</i>, but no characters are consumed.</td></tr>
<tr><td><tt><b>(?!</b></tt><i>subpattern</i><tt><b>)</b></tt></td><td>Negative lookahead</td><td>The characters following the assertion must not match <i>subpattern</i>, but no characters are consumed.</td></tr>
</tbody></table>
</section>
<br>
<section id="alternatives">
<h3>Alternatives</h3>
A pattern can include different alternatives:<br>
<table class="boxed">
<tbody><tr><th>character</th><th>description</th><th>effects</th></tr>
<tr><td><tt><b>|</b></tt></td><td>Separator</td><td>Separates two alternative patterns or subpatterns.</td></tr>
</tbody></table>
A regular expression can contain multiple alternative patterns simply by separating them with the <i>separator operator</i> (<tt><b>|</b></tt>): The regular expression will match if any of the alternatives match, and as soon as one does.<br>
<br>
Subpatterns (in groups or assertions) can also use the <i>separator operator</i> to separate different alternatives.<br>
</section>
<br>
<section id="character_classes">
<h3>Character classes</h3>
A character class defines a category of characters. It is introduced by enclosing its descriptors in square brackets (<tt>[</tt> and <tt>]</tt>).<br>
The regex object attempts to match the entire character class against a single character in the target sequence (unless a quantifier specifies otherwise).<br>
The character class can contain any combination of:<br>
<ul>
<li><b>Individual characters:</b> Any character specified is considered part of the class (except the characters <tt><b>\</b></tt>, <tt><b>[</b></tt>, <tt><b>]</b></tt> and <tt><b>-</b></tt> when they have a special meaning as described in the following paragraphs).<br>
For example:<br>
<tt>[abc]</tt> matches <tt>a</tt>, <tt>b</tt> or <tt>c</tt>.<br>
<tt>[^xyz]</tt> matches any character except <tt>x</tt>, <tt>y</tt> and <tt>z</tt>.<br>
</li>
<li><b>Ranges:</b> They can be specified by using the <i>hyphen character</i> (<tt>-</tt>) between two valid characters.<br>
For example:<br>
<tt>[a-z]</tt> matches any lowercase letter (<tt>a</tt>, <tt>b</tt>, <tt>c</tt>, ... until <tt>z</tt>).<br>
<tt>[abc1-5]</tt> matches either <tt>a</tt>, <tt>b</tt> or <tt>c</tt>, or a digit between <tt>1</tt> and <tt>5</tt>.<br>
</li>
<li><b>POSIX-like classes:</b> A whole set of predefined classes can be added to a custom character class. There are three kinds:<br>
<table class="boxed">
<tbody><tr><th>class</th><th>description</th><th>notes</th></tr>
<tr><td><tt><b>[:</b></tt><i>classname</i><tt><b>:]</b></tt></td><td>character class</td><td>Uses the <i>regex traits</i>' isctype member with the appropriate type gotten from applying lookup_classname member on <i>classname</i> for the match.</td></tr>
<tr><td><tt><b>[.</b></tt><i>classname</i><tt><b>.]</b></tt></td><td>collating sequence</td><td>
Uses the <i>regex traits</i>' lookup_collatename to interpret <i>classname</i>.</td></tr>
<tr><td><tt><b>[=</b></tt><i>classname</i><tt><b>=]</b></tt></td><td>character equivalents</td><td>
Uses the <i>regex traits</i>' transform_primary of the result of regex_traits::lookup_collatename for <i>classname</i> to check for matches.</td></tr>
</tbody></table>
The choice of available classes depend on the regex traits type and on its selected locale. But at least the following character classes shall be recognized by any regex traits type and locale:<br>
<table class="boxed">
<tbody><tr><th>class</th><th>description</th><th>equivalent (with regex_traits, default locale)</th></tr>
<tr><td><tt>[:alnum:]</tt></td><td>alpha-numerical character</td><td>isalnum</td></tr>
<tr><td><tt>[:alpha:]</tt></td><td>alphabetic character</td><td>isalpha</td></tr>
<tr><td><tt>[:blank:]</tt></td><td>blank character</td><td>isblank</td></tr>
<tr><td><tt>[:cntrl:]</tt></td><td>control character</td><td>iscntrl</td></tr>
<tr><td><tt>[:digit:]</tt></td><td>decimal digit character</td><td>isdigit</td></tr>
<tr><td><tt>[:graph:]</tt></td><td>character with graphical representation</td><td>isgraph</td></tr>
<tr><td><tt>[:lower:]</tt></td><td>lowercase letter</td><td>islower</td></tr>
<tr><td><tt>[:print:]</tt></td><td>printable character</td><td>isprint</td></tr>
<tr><td><tt>[:punct:]</tt></td><td>punctuation mark character</td><td>ispunct</td></tr>
<tr><td><tt>[:space:]</tt></td><td>whitespace character</td><td>isspace</td></tr>
<tr><td><tt>[:upper:]</tt></td><td>uppercase letter</td><td>isupper</td></tr>
<tr><td><tt>[:xdigit:]</tt></td><td>hexadecimal digit character</td><td>isxdigit</td></tr>
<tr><td><tt>[:d:]</tt></td><td>decimal digit character</td><td>isdigit</td></tr>
<tr><td><tt>[:w:]</tt></td><td>word character</td><td>isalnum</td></tr>
<tr><td><tt>[:s:]</tt></td><td>whitespace character</td><td>isspace</td></tr>
</tbody></table>
Please note that the brackets in the class names are additional to those opening and closing the class definition.<br>
For example:<br>
<tt>[<tt>[:alpha:]</tt>]</tt> is a character class that matches any alphabetic character.<br>
<tt>[abc[:digit:]]</tt> is a character class that matches <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, or a digit.<br>
<tt>[^[:space:]]</tt> is a character class that matches any character except a whitespace.<br>
</li>
<li><b>Escape characters:</b> All escape characters described above can also be used within a character class specification. The only change is with <tt>\b</tt>, that here is interpreted as a backspace character (<tt>\u0008</tt>) instead of a word boundary.<br>
Notice that within a class definition, those characters that have a special meaning in the regular expression (such as <tt>*</tt>, <tt>.</tt>, <tt>$</tt>) don't have such a meaning and are interpreted as normal characters (so they do not need to be escaped). Instead, within a class definition, the hyphen (<tt>-</tt>) and the brackets (<tt>[</tt> and <tt>]</tt>) do have special meanings under some circumstances, in which case they should be placed within the class in other locations where they do not have such special meaning, or be escaped with a backslash (<tt>\</tt>).<br>
</li>
</ul>
<br>
Character classes support depend heavily on the regex traits used by the regex object: the regex object calls its traits's isctype member function with the appropriate arguments. For the standard regex_traits object using the default locale, see cctype for a classification of characters.<br>
</section>

</body></html>